---
import StatsCard from "@/components/dashboard/StatsCard.astro";
import { parseUsersMetricData } from "@/utils/metrics";


const { helper, token } = Astro.props;
// Obtenemos las metricasmos las metricas necesarias
const metrics = await helper.getUserMetrics(token);
let stats = {
  totalUsers: 0,
  activeUsers: 0,
  newUsers: 0,
  conversionRate: 0,
  changes: {
    totalUsers: "+0%",
    activeUsers: "+0%",
    newUsers: "+0%",
    conversionRate: "+0%",
  },
};

if (metrics.success && metrics.data.rows.length > 0) {
  const parsed = metrics.data.rows.map(parseUsersMetricData);

  const latest = parsed[parsed.length - 1];
  const previous = parsed.length > 1 ? parsed[parsed.length - 2] : null;

  stats.totalUsers = latest.totalUsers;
  stats.activeUsers = latest.activeUsers;
  stats.newUsers = latest.newUsers;

  const convRate = (latest.engagedSessions / latest.sessions) * 100;
  stats.conversionRate = convRate;

  // Calcular cambios vs mes anterior
  if (previous) {
    if (previous.totalUsers > 0) {
      const totalChange = ((latest.totalUsers - previous.totalUsers) / previous.totalUsers) * 100;
      stats.changes.totalUsers = `${totalChange > 0 ? "+" : ""}${totalChange.toFixed(1)}%`;
    } else {
      stats.changes.totalUsers = `+${latest.totalUsers}`;
    }

    if (previous.activeUsers > 0) {
      const activeChange = ((latest.activeUsers - previous.activeUsers) / previous.activeUsers) * 100;
      stats.changes.activeUsers = `${activeChange > 0 ? "+" : ""}${activeChange.toFixed(1)}%`;
    } else {
      stats.changes.activeUsers = `+${latest.activeUsers}`;
    }

    if (previous.newUsers > 0) {
      const newChange = ((latest.newUsers - previous.newUsers) / previous.newUsers) * 100;
      stats.changes.newUsers = `${newChange > 0 ? "+" : ""}${newChange.toFixed(1)}%`;
    } else {
      stats.changes.newUsers = `+${latest.newUsers}`;
    }

    const prevRate = (previous.engagedSessions / previous.sessions) * 100;
    const convChange = convRate - prevRate;
    stats.changes.conversionRate = `${convChange > 0 ? "+" : ""}${convChange.toFixed(1)}%`;
  } else {
    stats.changes.totalUsers = `+${latest.totalUsers}`;
    stats.changes.activeUsers = `+${latest.activeUsers}`;
    stats.changes.newUsers = `+${latest.newUsers}`;
    stats.changes.conversionRate = `${convRate.toFixed(1)}%`;
  }
}
---

<div class="mb-8">
  <h1 class="text-3xl font-bold text-[#131313] mb-2">Panel de Administración</h1>
  <p class="text-[#8a4141]">Monitoreo y estadísticas de Amanah Academia</p>
</div>
<!-- Stats Cards -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
  <StatsCard
    title="Total Usuarios"
    value={stats.totalUsers.toLocaleString()}
    change={stats.changes.totalUsers}
    iconType="users"
  />
  <StatsCard
    title="Usuarios Activos"
    value={stats.activeUsers.toLocaleString()}
    change={stats.changes.activeUsers}
    iconType="active"
  />
  <StatsCard
    title="Nuevos Este Mes"
    value={stats.newUsers.toLocaleString()}
    change={stats.changes.newUsers}
    iconType="new"
  />
  <StatsCard
    title="Tasa de Conversión"
    value={`${stats.conversionRate.toFixed(1)}%`}
    change={stats.changes.conversionRate}
    iconType="conversion"
  />
</div>

<div class="bg-[#fff4e1] rounded-xl shadow-sm border border-[#fee8d6] p-6">
  <div class="mb-6">
    <h2 class="text-xl font-bold text-[#131313] mb-2">Analiticas</h2>
    <p class="text-[#8a4141] text-sm">Evolución de la web en los últimos 12 meses</p>
  </div>

  <div class="relative" style="height: 400px;">
    <canvas id="activeUsersChart"></canvas>
  </div>
</div>

<script>
  import { ApiService } from "@/services/helper";
  import { parseArticleMetricData, parseUsersMetricData, parseClassMetricData, mapToMonths } from "@/utils/metrics";
  import Chart from "chart.js/auto";

  document.addEventListener("DOMContentLoaded", async () => {
    const ctx = document.getElementById("activeUsersChart") as HTMLCanvasElement;

    if (!ctx) return;

    // Crear gradiente para el fondo del área
    const gradient = ctx.getContext("2d")!.createLinearGradient(0, 0, 0, 400);
    gradient.addColorStop(0, "rgba(178, 68, 58, 0.25)");
    gradient.addColorStop(1, "rgba(178, 68, 58, 0)");

    const currentMonth = new Date().getMonth();
    const monthLabels = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
    const currentYear = new Date().getFullYear();

    const makeLastNMonths = (currentMonthIndex: number, count: number) => {
      return Array.from({ length: count }, (_, i) => {
        const monthIndex = (currentMonthIndex - (count - 1 - i) + 12) % 12;
        return `${monthLabels[monthIndex]} ${currentYear}`;
      });
    };

    // Y actualiza getMonthKey para usar año completo:
    const getMonthKey = (label: string) => {
      const monthIndex = monthLabels.indexOf(label.split(" ")[0]);
      const year = label.split(" ")[1];
      return `${year}${String(monthIndex + 1).padStart(2, "0")}`;
    };

    try {
      const helper = new ApiService();

      // Obtener todas las métricas
      const [userMetrics, articlesMetrics, classMetrics] = await Promise.all([
        helper.getUserMetrics(),
        helper.getArticlesMetrics(),
        helper.getClassMetrics(),
      ]);
      if (!userMetrics.success || !articlesMetrics.success || !classMetrics.success)
        throw new Error("Error al obtener métricas");

      // Parsear todas las filas, artículos, usuarios y clases
      const parsedUserData = userMetrics.data.rows.map(parseUsersMetricData);
      const parsedArticleData = articlesMetrics.data.rows.map(parseArticleMetricData);
      const parsedClassData = classMetrics.data.rows.map(parseClassMetricData);

      // Agrupar por total de clases por mes
      const totalByMonth = new Map<string, number>();
      parsedClassData.forEach((item) => {
        const currentTotal = totalByMonth.get(item.yearMonth) || 0;
        totalByMonth.set(item.yearMonth, currentTotal + item.bookings);
      });

      // Agrupar clics a articulos totales por mes
      const articleClicksMap = new Map<string, number>();
      parsedArticleData.forEach((item) => {
        const current = articleClicksMap.get(item.yearMonth) || 0;
        articleClicksMap.set(item.yearMonth, current + item.eventCount);
      });

      // Crear mapas para cada métrica que necesites visualizar
      const activeUsersMap = new Map<string, number>();
      const sessionsMap = new Map<string, number>();
      parsedUserData.forEach((m) => {
        activeUsersMap.set(m.yearMonth, m.activeUsers);
        sessionsMap.set(m.yearMonth, m.sessions);
      });

      // Generar labels de los últimos 6 meses
      const labels = makeLastNMonths(currentMonth, 6);

      // Datos de reservas de clases
      const bookingsData = labels.map((l) => totalByMonth.get(getMonthKey(l)) || 0);

      // Mapear a los labels del chart
      const articleClicksData = mapToMonths(articleClicksMap, labels, monthLabels);
      const sessionsChartData = mapToMonths(sessionsMap, labels, monthLabels);
      const activeUsersChartData = mapToMonths(activeUsersMap, labels, monthLabels);

      new Chart(ctx, {
        type: "line",
        data: {
          labels: labels,
          datasets: [
            {
              label: "Usuarios Activos",
              data: activeUsersChartData,
              borderColor: "#b2443a",
              backgroundColor: gradient,
              borderWidth: 3,
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointBackgroundColor: "#b2443a",
            },
            {
              label: "Sesiones",
              data: sessionsChartData,
              borderColor: "#fa8072",
              backgroundColor: "rgba(250, 128, 114, 0.1)",
              borderWidth: 3,
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointBackgroundColor: "#fa8072",
            },
            {
              label: "Reservas de Clases",
              data: labels.map((l) => totalByMonth.get(getMonthKey(l)) || 0),
              borderColor: "#6d0006",
              backgroundColor: "rgba(109, 0, 6, 0.1)",
              borderWidth: 3,
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointBackgroundColor: "#6d0006",
            },
            {
              label: "Clics de Artículos",
              data: articleClicksData,
              borderColor: "#ffbba8",
              borderWidth: 2,
              borderDash: [5, 5],
              fill: false,
              pointRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: "top",
              align: "end",
              labels: {
                usePointStyle: true,
                pointStyle: "circle",
                padding: 20,
                font: {
                  size: 13,
                  family: "'Inter', sans-serif",
                },
                color: "#8a4141",
                boxWidth: 8,
                boxHeight: 8,
              },
              onClick: (e, legendItem, legend) => {
                const index = legendItem.datasetIndex!;
                const chart = legend.chart;
                const meta = chart.getDatasetMeta(index);
                meta.hidden = !meta.hidden;
                chart.update();
              },
            },
            tooltip: {
              backgroundColor: "rgba(95, 73, 73, 0.95)",
              titleColor: "#fff4e1",
              bodyColor: "#fee8d6",
              padding: 12,
              borderColor: "rgba(178, 68, 58, 0.3)",
              borderWidth: 1,
              displayColors: false,
              callbacks: {
                label: function (context) {
                  const value = context.parsed.y ?? 0;
                  const label = context.dataset.label || "";
                  return `${label}: ${value.toLocaleString()}`;
                },
                afterLabel: function (context) {
                  const currentValue = context.parsed.y ?? 0;

                  // Si es el primer punto, no hay comparación
                  if (context.dataIndex === 0) {
                    return "";
                  }

                  const previousValue = context.dataset.data[context.dataIndex - 1] as number;
                  const change = currentValue - previousValue;

                  // Si el valor anterior era 0, solo mostrar el cambio absoluto
                  if (previousValue === 0) {
                    return change > 0 ? `↗ +${change}` : "";
                  }

                  const percentChange = ((change / previousValue) * 100).toFixed(1);
                  return change >= 0 ? `↗ +${change} (+${percentChange}%)` : `↘ ${change} (${percentChange}%)`;
                },
              },
            },
          },
          scales: {
            y: {
              beginAtZero: false,
              min: 0,
              max: Math.max(...activeUsersChartData, ...sessionsChartData, ...bookingsData, ...articleClicksData) * 1.2,
              ticks: {
                color: "#8a4141",
                font: {
                  size: 12,
                },
                callback: function (value) {
                  return value.toLocaleString();
                },
              },
              grid: {
                color: "rgba(138, 65, 65, 0.1)",
              },
              border: {
                display: false,
              },
            },
            x: {
              ticks: {
                color: "#8a4141",
                font: {
                  size: 12,
                },
                maxRotation: 45,
                minRotation: 45,
              },
              grid: {
                display: false,
              },
              border: {
                display: false,
              },
            },
          },
          interaction: {
            intersect: false,
            mode: "nearest",
          },
        },
      });
    } catch (error) {
      console.error("Error fetching or rendering chart data:", error);
    }
  });
</script>
