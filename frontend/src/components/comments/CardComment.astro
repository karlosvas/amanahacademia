---
import StarGroup from "./StarGroup.astro";
import Avatar from "../common/Avatar.astro";
import CommentModal from "@/components/comments/CommentModal.astro";
import EditCommentButtons from "./EditCommentButtons.astro";
import CommentActions from "./CommentActions.astro";
import ReplyForm from "./ReplyForm.astro";
import ReplyList from "./ReplyList.astro";
import { buttonsCommentTraductions } from "../../../i18n/index";
import type { Comment } from "@/types/bakend-types";
import type { AvatarProps, CommentI18n } from "@/types/types";

// Comentario de la card
const comment = Astro.props.comment as Comment;
const idCommentShared = Astro.props.id as string;
const footer = Astro.props.footer as boolean;
// Traducciones
const data = Astro.props.data as CommentI18n;

if (!comment) throw new Error("Comment data is required");

// Info para las props del avatar
const avatar: AvatarProps = {
  name: comment.name ?? "Invitado",
  url_img: comment.url_img ?? "",
};

// Lenguaje actual del commentario
const lang = Astro.cookies.get("lang")?.value || "es";
---

<div
  data-comment-id={comment.id}
  class="relative bg-lightSalmon w-full rounded-lg scroll-fade-in overflow-hidden flex flex-col h-full"
>
  <EditCommentButtons buttonsCommentTraductions={buttonsCommentTraductions} lang={lang} isReply={false} />

  <!-- Header compacto -->
  <div class="p-4">
    <div class="flex items-center space-x-3">
      <!-- Avatar pequeño -->
      <Avatar info={avatar} />

      <!-- Info del usuario compacta -->
      <div class="flex-1 min-w-0">
        <div class="flex items-center justify-between">
          <h5 class="text-sm font-medium truncate w-32">
            {comment.name}
          </h5>
          <time class="text-xs mr-2">
            {comment.timestamp}
          </time>
        </div>
        <div class="mt-0.5 flex items-start">
          <StarGroup star={comment.stars} size={12} />
        </div>
      </div>
    </div>

    <!-- Contenido del comentario -->
    <div class="mt-3">
      <p class="text-[var(-text-gray-800)] text-sm leading-snug line-clamp-3">
        {comment.content}
      </p>
    </div>
  </div>

  <!-- Actions (like y responder) -->
  {
    footer && (
      <CommentActions
        commentId={comment.id}
        likeCount={comment.like ?? 0}
        usersLiked={comment.users_liked ?? []}
        buttonsCommentTraductions={buttonsCommentTraductions}
        lang={lang}
      />
    )
  }

  <!-- Formulario de respuesta -->
  <ReplyForm buttonsCommentTraductions={buttonsCommentTraductions} lang={lang} />

  <!-- Respuestas anidadas -->
  <ReplyList replies={comment.reply ?? []} buttonsCommentTraductions={buttonsCommentTraductions} lang={lang} />
</div>

<CommentModal id={idCommentShared} edit={true} data={data} />

<script>
  import { ApiService } from "@/services/helper";
  import { getFirebaseAuth } from "@/services/firebase";
  import { showModalAnimation } from "@/utils/modals";
  import { FrontendErrorCode, getErrorToast } from "@/enums/enums";
  import {
    handleSubmitReply,
    handleDeleteComment,
    handleEditComment,
    handleDeleteReply,
    handleEditReply,
  } from "@/services/comments";
  import { buttonsCommentTraductions } from "i18n";
  import toast from "solid-toast";
  import { isFrontendError, FrontendError } from "@/types/types";

  const helper = new ApiService();
  const lang = document.cookie.match(/lang=([^;]+)/)?.[1] || "es";

  // Selectors
  const options = document.querySelectorAll(".comment-config");
  const replyButton = document.querySelectorAll(".reply-btn");
  const replyConfigs = document.querySelectorAll(".reply-config");
  const menus = document.querySelectorAll(".comment-config-menu");
  const replyMenus = document.querySelectorAll(".reply-config-menu");
  const editButtonsComment = document.querySelectorAll(".comment-config-menu li:first-child button");
  const deleteButtonsComment = document.querySelectorAll(".comment-config-menu li:last-child button");
  const editReplyButtons = document.querySelectorAll(".reply-config-menu li:first-child button");
  const deleteReplyButtons = document.querySelectorAll(".reply-config-menu li:last-child button");

  // Cerrar menus al hacer click fuera
  document.addEventListener("click", () => {
    menus.forEach((menu) => !menu.classList.contains("hidden") && menu.classList.add("hidden"));
    replyMenus.forEach((menu) => !menu.classList.contains("hidden") && menu.classList.add("hidden"));
  });

  // Toggle formulario de reply
  replyButton.forEach((btn) => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const commentEl = (btn as HTMLElement).closest("[data-comment-id]") as HTMLElement | null;
      if (!commentEl) return;

      const replyForm = commentEl.querySelector<HTMLElement>(".reply-form");
      if (!replyForm) return;

      replyForm.classList.toggle("hidden");
      const isNowHidden = replyForm.classList.contains("hidden");

      if (!isNowHidden) {
        const ta = replyForm.querySelector<HTMLTextAreaElement>(".reply-textarea");
        ta?.focus();
      }
    });
  });

  // Envío y cancelación de respuestas (event delegation)
  document.addEventListener("click", async (e) => {
    const target = e.target as HTMLElement;

    if (target.classList.contains("submit-reply-btn")) {
      e.stopPropagation();
      const commentEl = target.closest("[data-comment-id]") as HTMLElement | null;
      if (commentEl) await handleSubmitReply(helper, commentEl, buttonsCommentTraductions[lang]);
    }

    if (target.classList.contains("cancel-reply-btn")) {
      e.stopPropagation();
      const replyForm = target.closest(".reply-form") as HTMLElement | null;
      if (replyForm) {
        replyForm.classList.add("hidden");
        const textarea = replyForm.querySelector<HTMLTextAreaElement>(".reply-textarea");
        if (textarea) textarea.value = "";
      }
    }
  });

  // Abrir opciones de comentario
  options.forEach((option, index) => {
    option.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        const auth = await getFirebaseAuth();
        if (!auth.currentUser) throw new FrontendError(getErrorToast(FrontendErrorCode.NEED_AUTHENTICATION));
        menus[index].classList.toggle("hidden");
      } catch (e) {
        isFrontendError(e) ? toast.error(e.message) : toast.error(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));
      }
    });
  });

  // Eliminar comentario
  deleteButtonsComment.forEach((btn, idx) => {
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        const commentDiv = btn.closest("[data-comment-id]");
        if (!commentDiv) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const commentId: string = commentDiv.getAttribute("data-comment-id") as string;
        if (!commentId) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        await handleDeleteComment(helper, commentId);

        menus[idx].classList.add("hidden");
        toast.success("Comentario eliminado");
        commentDiv.remove();
      } catch (e) {
        isFrontendError(e) ? toast.error(e.message) : toast.error(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));
      }
    });
  });

  // Editar comentario
  editButtonsComment.forEach((btn) => {
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        const commentDiv = btn.closest("[data-comment-id]");
        if (!commentDiv) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const commentId: string = commentDiv.getAttribute("data-comment-id") as string;
        if (!commentId) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        await handleEditComment(helper, commentId);

        const modal = document.getElementById(commentId) as HTMLDialogElement;
        const form = modal.querySelector("form");
        showModalAnimation(modal, form, true);
      } catch (e) {
        isFrontendError(e) ? toast.error(e.message) : toast.error(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));
      }
    });
  });

  // Abrir configuraciones de reply
  replyConfigs.forEach((config, index) => {
    config.addEventListener("click", async (e) => {
      e.stopPropagation();
      replyMenus[index].classList.toggle("hidden");
    });
  });

  // Eliminar respuesta
  deleteReplyButtons.forEach((btn) => {
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        const replyItem = btn.closest(".reply-item") as HTMLElement | null;
        if (!replyItem) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const replyId = replyItem.dataset.replyId ?? replyItem.getAttribute("data-reply-id") ?? null;
        const commentId = replyItem.closest("[data-comment-id]")?.getAttribute("data-comment-id") ?? null;

        if (!replyId || !commentId) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        await handleDeleteReply(helper, commentId, replyId);

        const commentDiv = replyItem.closest("[data-comment-id]");
        if (!commentDiv) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        replyItem.remove();

        const repliesSection = commentDiv.querySelector(".replies-section");
        if (!repliesSection) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const repliesContainer = repliesSection.querySelector(".replies-container");
        const countElement = repliesSection.querySelector(".replies-count");
        if (!repliesContainer || !countElement) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const newCount = repliesContainer.children.length;
        newCount === 0
          ? repliesSection.remove()
          : (countElement.textContent = `${newCount} ${newCount === 1 ? "respuesta" : "respuestas"}`);

        toast.success("Respuesta eliminada correctamente");
      } catch (e) {
        isFrontendError(e) ? toast.error(e.message) : toast.error(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));
      }
    });
  });

  // Editar respuesta
  editReplyButtons.forEach((btn) => {
    btn.addEventListener("click", async (e) => {
      e.stopPropagation();

      try {
        const replyItem = btn.closest(".reply-item");
        if (!replyItem) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const commentDiv = btn.closest("[data-comment-id]");
        if (!commentDiv) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        // Verificar propiedad
        const auth = await getFirebaseAuth();
        const replyAuthor = replyItem.getAttribute("data-reply-author");

        if (replyAuthor !== auth.currentUser?.uid)
          throw new FrontendError(getErrorToast(FrontendErrorCode.MUST_BE_OWNER));

        const commentId = commentDiv.getAttribute("data-comment-id");
        const contentElement = replyItem.querySelector(".reply-content") as HTMLElement;

        if (!commentId || !contentElement) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        const currentContent = contentElement.textContent?.trim() || "";

        // Ocultar contenido y mostrar formulario de edición
        contentElement.style.display = "none";

        let editForm = replyItem.querySelector(".edit-reply-form") as HTMLElement;
        if (!editForm) {
          editForm = document.createElement("div");
          editForm.className = "edit-reply-form mt-2";
          editForm.innerHTML = `
          <textarea class="edit-reply-textarea w-full p-2 text-xs border border-salmon rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-[var(--color-red)]" rows="3">${currentContent}</textarea>
          <div class="flex justify-end space-x-2 mt-2">
            <button class="cancel-edit-reply-btn px-3 py-1 text-xs rounded-md hover:bg-salmon transition-colors">
              ${buttonsCommentTraductions[lang].cancel}
            </button>
            <button class="save-edit-reply-btn px-3 py-1 text-xs bg-lightRed text-white rounded-md hover:bg-[var(--color-red)] transition-colors">
              ${buttonsCommentTraductions[lang].send}
            </button>
          </div>
        `;
          contentElement.parentElement?.appendChild(editForm);
        } else {
          const textarea = editForm.querySelector(".edit-reply-textarea") as HTMLTextAreaElement;
          if (textarea) textarea.value = currentContent;
          editForm.style.display = "block";
        }

        // Ocultar menú
        const replyMenu = btn.closest(".reply-config-menu");
        if (replyMenu) replyMenu.classList.add("hidden");

        // Cancelar edición
        const cancelBtn = editForm.querySelector(".cancel-edit-reply-btn");
        cancelBtn?.addEventListener(
          "click",
          () => {
            contentElement.style.display = "block";
            editForm.style.display = "none";
          },
          { once: true }
        );

        // Guardar edición
        const saveBtn = editForm.querySelector(".save-edit-reply-btn");
        if (!saveBtn) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

        saveBtn.addEventListener(
          "click",
          async () => {
            const textarea = editForm.querySelector(".edit-reply-textarea") as HTMLTextAreaElement;
            const newContent = textarea?.value.trim() || "";
            const replyId = replyItem.getAttribute("data-reply-id");

            if (!replyId) throw new FrontendError(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));

            const result = await handleEditReply(helper, commentId, replyId, newContent, currentContent);

            if (result) {
              toast.success("Respuesta editada correctamente");
              contentElement.textContent = newContent;
              window.location.reload();
            } else {
              contentElement.style.display = "block";
              editForm.style.display = "none";
            }
          },
          { once: true }
        );
      } catch (error) {
        isFrontendError(error)
          ? toast.error(error.message)
          : toast.error(getErrorToast(FrontendErrorCode.UNKNOWN_ERROR));
      }
    });
  });
</script>
